# file opened: Link.a80
  1   0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2   0000              ;;   Tetris 1D "game" for PMI-80  ;;
  3   0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4   0000
  5   0000              ;; Source 2: Link final code
  6   0000
  7   0000              dstadd	=	#1CA0	;; Address in RAM for depack of part 2 (must be the same as in Main.a80 !)
  8   0000
  9   0000              	OUTPUT	tetris1d.cod
 10   0000
 11   0000              	ORG	#0400
 12   0400 31 A0 1C     start	ld	sp,dstadd
 13   0403 CD 0C 05     	call	depack
 14   0406
 15   0406              	INCBIN	Main.cod
 16   050C
 17   050C              depack
 18   050C              lzxspd	=	0
 19   050C
 20   050C              	DEFINE	declzx_user_params
 21   050C              	DEFINE  declzx_pack_params
 22   050C              	INCLUDE	Main.inc
# file opened: Main.inc
  1+  050C              revers	=	0
  2+  050C              typcom	=	3
  3+  050C              typpos	=	7
  4+  050C              bytcop	=	4
  5+  050C              ofset1	=	5
  6+  050C              ofset2	=	0
  7+  050C
  8+  050C              mindst	=	4
  9+  050C              maxdct	=	65535
 10+  050C              deplen	=	118
 11+  050C              pcklen	=	627
 12+  050C              totlen	=	833
 13+  050C
# file closed: Main.inc
 23   050C              	INCLUDE DecLzx02-8080.asm
# file opened: DecLzx02-8080.asm
  1+  050C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2+  050C              ;; Busy soft ;; DecLzx02 Universal depacker for 8080 ;; 12.09.2021 ;;
  3+  050C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4+  050C
  5+  050C              	OPT	listact	;; Exclude not compiled branches IF/ENDIF from listing
  6+  050C
  7+  050C              ;; Compilation:  SjASMPlus --i8080 DecLzx02-8080.a80
  8+  050C
  9+  050C              ;; Setting user parameters - addresses of depacker, source and destinaton data, and optimization.
 10+  050C              ;; There are two possibilities how the setting can be provided:
 11+  050C              ;;
 12+  050C              ;;  1. Assign these labes elsewhere (i.e. in some other source code what includes this depacker)
 13+  050C              ;;     In this case, comment out these definitions, or define symbol "declzx_user_params" in your source.
 14+  050C              ;;
 15+  050C              ;;  2. Set all following values here manually
 16+  050C
 17+  050C                IFNDEF declzx_user_params ;; Skip next assigns if all user data are already defined elsewhere
 37+  050C                ENDIF
 38+  050C
 39+  050C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 40+  050C
 41+  050C              ;; Setting pack parameters = compression identification and data overlay check
 42+  050C              ;;
 43+  050C              ;; Next setting are generated by LzxPack and depends on used compression.
 44+  050C              ;; There are two possibilities how the setting can be provided:
 45+  050C              ;;  1. Read from *.inc file directly generated by LzxPack with option -i
 46+  050C              ;;  2. Manual setting according to compression identification and parameters
 47+  050C
 48+  050C              ;; 1st possibility - read setting from *.inc file:
 49+  050C              ;; It is enough to uncomment following two lines
 50+  050C              ;; with include and define directives and fill
 51+  050C              ;; corresponding file name in this directive:
 52+  050C
 53+  050C              ;	INCLUDE	filename.inc
 54+  050C              ;	DEFINE	declzx_pack_params
 55+  050C
 56+  050C              ;; 2nd possiblity - manual setting:
 57+  050C              ;; It is needed to set proper values for following 10 labels:
 58+  050C              ;;
 59+  050C              ;;   Setting compression identification -tnXYcNoAoB (mandatory)
 60+  050C              ;;   (If some parameter is not present in identification, it does not matter)
 61+  050C
 62+  050C                IFNDEF declzx_pack_params ;; If parameters are already defined (i.e. by previous include), this IF skips following definitions
 82+  050C                ENDIF
 83+  050C
 84+  050C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 85+  050C
 86+  050C              ;; Internal definitions
 87+  050C
 88+  050C              ;; Systems for coding unpacked data and sequence lengths (values of label typcom)
 89+  050C
 90+  050C              COMBLX	=	1	;; Simple block compression - Elias-gamma length for both sequence and unpacked block (real sequence 1+ length supports compress simple bytes)
 91+  050C              COMBLC	=	2	;; Simple block compression - Elias-gamma length for both sequence and unpacked block (real sequence 2+ length has width more 1 bit: EG+1)
 92+  050C              COMZX9	=	3	;; Similar to ZX7 compression - 1 bit for each unpacked byte and 1 bit + Elias-gamma length for sequence 1+ bytes (supports packing of simple bytes)
 93+  050C              COMZX8	=	4	;; Similar to ZX7 compression - 1 bit for each unpacked byte and 1 bit + Elias-gamma length for sequence 2+ bytes (length EG+1 bit)
 94+  050C              COMBS2	=	5	;; Bitstream 1:unpack byte, 01:seq 2 bytes, 001:seq 3 bytes, 0001:seq 4+ bytes, 00000:1 unpack + rep offset, 00000:unpacked block 10+ bytes
 95+  050C              COMBX1	=	6	;; Bitstream 1:unpack, 01:seq2, 001:seq3, 0001:copied, 00001:seq4+, 000001:unpack + rep.offset, 0000001:copied + rep.offs, 0000000:block 12+
 96+  050C              COMBX2	=	7	;; Bitstream 1:unpack, 01:seq2, 001:copied, 0001:seq3, 00001:seq4+, 000001:unpack + rep.offset, 0000001:copied + rep.offs, 0000000:block 12+
 97+  050C              COMBX3	=	8	;; Bitstream 1:unpack, 01:copied, 001:seq2, 0001:seq3, 00001:seq4+, 000001:unpack + rep.offset, 0000001:copied + rep.offs, 0000000:block 12+
 98+  050C              COMSX1	=	9	;; Bitstream 1:seq 2+, 01:unpack, 001:copied, 0001:unpack + rep offset, 00001:copied + rep offset, 00000:unpack block 5+ bytes
 99+  050C
100+  050C              ;; Systems for coding offsets in sequences (values of label typpos)
101+  050C
102+  050C              POSOF1	=	1	;; One fixed offset used for all sequences
103+  050C              POSOF2	=	2	;; Two fixed offsets (similar to ZX7)
104+  050C              POSOF3	=	3	;; Three fixed step offsets (1,2,3 or 2,4,6 or 3,6,9 or 4,8,12 or 5,10,15)
105+  050C              POSOF4	=	4	;; Four fixed step offsets (1,2,3,4 or 2,4,6,8 or 3,6,9,12 or 4,8,12,16 bits)
106+  050C              ;;;;;;	=	5	;; (not used)
107+  050C              POSOV1	=	6	;; Simple variable Elias-gamma coding offset
108+  050C              POSOV2	=	7	;; One fixed offset and one variable offset
109+  050C              POSOV3	=	8	;; Two fixed offsets A,B and one variable Elias-gamma offset EG+B bits and +A addition
110+  050C              POSOV4	=	9	;; Three fixed step offsets (1,2,3 or 2,4,6 or 3,6,9 or 4,8,12) and one variable offset
111+  050C
112+  050C              ;; You can use these constants to define labels "typcom" and "typpos" in definition of compress type -tnXYcNoAoB
113+  050C
114+  050C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
115+  050C
116+  050C              ;; Macro definitions
117+  050C
118+  050C              LDX	MACRO
130+  050C              	ENDM
131+  050C
132+  050C
133+  050C              PSALDX	MACRO
137+  050C              	ENDM
138+  050C
139+  050C              LDXR	MACRO
159+  050C              	ENDM
160+  050C
161+  050C              PSALDXR	MACRO
165+  050C              	ENDM
166+  050C
167+  050C              INCHL	MACRO
173+  050C              	ENDM
174+  050C
175+  050C              INCOFS	MACRO
177+  050C              	ENDM
178+  050C
179+  050C              GETBIT	MACRO			;; Get one bit from bitstream
192+  050C              	ENDM
193+  050C
194+  050C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
195+  050C
196+  050C              ;; Validation of parameters 'typcom' and 'typpos'
197+  050C              ;; to make sure they contain only supported values
198+  050C
199+  050C              	ASSERT	typcom=COMBLX or typcom=COMBLC or typcom=COMZX9 or typcom=COMZX8 or typcom=COMBS2 or typcom=COMBX1 or typcom=COMBX2 or typcom=COMBX3 or typcom=COMSX1
200+  050C              	ASSERT	typpos=POSOF1 or typpos=POSOF2 or typpos=POSOF3 or typpos=POSOF4 or                  typpos=POSOV1 or typpos=POSOV2 or typpos=POSOV3 or typpos=POSOV4
201+  050C
202+  050C              ;; Data overlay check
203+  050C              ;; to make sure destination depacked data does not overwrite source packed data not used yet
204+  050C
205+  050C              	IF revers
207+  050C              	ELSE
208+  050C              	  ASSERT  dstadd + totlen + mindst <= srcadd + pcklen  OR  srcadd + pcklen <= dstadd
209+  050C              	ENDIF
210+  050C
211+  050C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
212+  050C
213+  050C              ;; Start of depacker
214+  050C
215+  050C              ;; Set input and output addresses.
216+  050C              ;; If addresses are set into HL and DE from calling program,
217+  050C              ;; define the symbol "declzx_init_addres" to skip these settings.
218+  050C
219+  050C              declzx_start	IFNDEF declzx_init_addres	;; Skip next setting HL,DE if they are set from calling program.
220+  050C
221+  050C              		  IF revers
224+  050C              		  ELSE
225+  050C 21 88 05     		    ld	hl,srcadd
226+  050F 11 A0 1C     		    ld	de,dstadd
227+  0512              		  ENDIF
228+  0512
229+  0512              		ENDIF
230+  0512
231+  0512              ;; Input:
232+  0512              ;;   HL = address of source packed data
233+  0512              ;;   DE = address of destination to depack data
234+  0512              ;; When reversed direction (revers=1) is used, HL and DE must point to last byte of data.
235+  0512
236+  0512 3E 80        		ld	a,#80		;; Initial value what means there are no bits from bitstream in A
237+  0514
238+  0514              ;; Processing compression types and lengths
239+  0514
240+  0514              	    IF typcom=COMBLX
265+  0514              	    ENDIF
266+  0514
267+  0514
268+  0514              	    IF typcom=COMBLC
284+  0514              	    ENDIF
285+  0514
286+  0514
287+  0514              	    IF typcom=COMZX9
288+  0514
289+  0514              declzx_ldx	PSALDX			;; Copy one unpacked byte                 *** ZX9 compression ***
289+  0514 F5          >	  push af
289+  0515             >	  LDX
289+  0515             >	IF revers
289+  0515             >	ELSE
289+  0515 7E          >	  ld	a,(hl)	;; ldi
289+  0516 12          >	  ld	(de),a
289+  0517 23          >	  inc	hl
289+  0518 13          >	  inc	de
289+  0519             >	ENDIF
289+  0519 F1          >	  pop af
290+  051A              declzx_main	GETBIT
290+  051A             >
290+  051A             >    IF lzxspd			;; Speed optimized variant
290+  051A             >    ELSE
290+  051A CD 82 05    >	call	declzx_getbit	;; Length optimized variant
290+  051D             >    ENDIF
290+  051D             >
291+  051D DA 14 05     		jp	c,declzx_ldx	;; 1 ... one unpacked byte, 0 ... sequence
292+  0520 D5           		push	de
293+  0521 CD 65 05     		call	declzx_getegv0	;; Get length of sequence
294+  0524 D1           		pop	de
295+  0525 D8           		ret	c		;; Return if end mark occured
296+  0526 C5           		push	bc
297+  0527 0D           		dec	c
298+  0528 C2 3B 05     		jp	nz,declzx_sek	;; Jump if length > 1
299+  052B 04           		inc	b
300+  052C 05           		dec	b
301+  052D C2 3B 05     		jp	nz,declzx_sek
302+  0530 D5           		push	de
303+  0531 1E 04        		ld	e,bytcop	;; Sequence length = 1 means copying one standalone byte
304+  0533 CD 6E 05     		call	declzx_getnum	;; Read offset for copying byte from bitstream
305+  0536 D1           		pop	de
306+  0537 0C           		inc	c		;; Increment offset
307+  0538 C3 4C 05     		jp	declzx_copy	;; Jump copying sequence (in this case only one byte)
308+  053B
309+  053B              declzx_sek				;; Continue to read sequence offset
310+  053B
311+  053B              	    ENDIF
312+  053B
313+  053B
314+  053B              	    IF typcom=COMZX8
326+  053B              	    ENDIF
327+  053B
328+  053B
329+  053B              	    IF typcom=COMBS2
368+  053B              	    ENDIF
369+  053B
370+  053B
371+  053B              	    IF typcom=COMBX1
401+  053B              	    ENDIF
402+  053B
403+  053B
404+  053B              	    IF typcom=COMBX2
434+  053B              	    ENDIF
435+  053B
436+  053B
437+  053B              	    IF typcom=COMBX3
467+  053B              	    ENDIF
468+  053B
469+  053B
470+  053B              	    IF typcom=COMSX1
491+  053B              	    ENDIF
492+  053B
493+  053B
494+  053B              	    IF typcom=COMBX1 or typcom=COMBX2 or typcom=COMBX3 or typcom=COMSX1
515+  053B              	    ENDIF
516+  053B
517+  053B
518+  053B              ;; Clear carry if needed (some offset readings need CY=0 at begin)
519+  053B
520+  053B              	    IF (typcom >= COMBS2) and (typpos=POSOF1 or typpos=POSOF4 or typpos=POSOV4)
522+  053B              	    ENDIF
523+  053B
524+  053B
525+  053B              ;; Processing offsets
526+  053B
527+  053B              	    IF typpos=POSOF1
535+  053B              	    ENDIF
536+  053B
537+  053B
538+  053B              	    IF typpos=POSOF2
552+  053B              	    ENDIF
553+  053B
554+  053B
555+  053B              	    IF typpos=POSOF3
577+  053B              	    ENDIF
578+  053B
579+  053B
580+  053B              	    IF typpos=POSOF4
597+  053B              	    ENDIF
598+  053B
599+  053B
600+  053B              	    IF typpos=POSOV1
604+  053B              	    ENDIF
605+  053B
606+  053B
607+  053B              	    IF typpos=POSOV2
608+  053B D5           		push	de
609+  053C 01 00 00     		ld	bc,#0000	;; Init offset to 0				*** OV2 offset ***
610+  053F              		GETBIT
610+  053F             >
610+  053F             >    IF lzxspd			;; Speed optimized variant
610+  053F             >    ELSE
610+  053F CD 82 05    >	call	declzx_getbit	;; Length optimized variant
610+  0542             >    ENDIF
610+  0542             >
611+  0542 DC 65 05     		call	c,declzx_getegv0;; Case 1 ... Read Elias-Gamma - only additional variable part
612+  0545 1E 05        		ld	e,ofset1	;; Number of bits of shorter offset
613+  0547 CD 71 05     		call	declzx_getloop	;; Read shorter offset or fixed part of variable offset
614+  054A D1           		pop	de
615+  054B              		INCOFS			;; Increment offset value for range 1..X
615+  054B 03          >	  inc	bc
616+  054C
617+  054C              		ASSERT	ofset1 >= 1 and ofset1 <= 14
618+  054C              	    ENDIF
619+  054C
620+  054C
621+  054C              	    IF typpos=POSOV3
637+  054C              	    ENDIF
638+  054C
639+  054C
640+  054C              	    IF typpos=POSOV4
665+  054C              	    ENDIF
666+  054C
667+  054C
668+  054C              ;; Store actual offset for future "reused offset"
669+  054C
670+  054C              	    IF typcom=COMBS2 or typcom=COMBX1 or typcom=COMBX2 or typcom=COMBX3 or typcom=COMSX1
676+  054C              	    ENDIF
677+  054C
678+  054C
679+  054C              ;; Copy sequence
680+  054C              ;;
681+  054C              ;; BC=offset, (SP)=length, DE=destination
682+  054C              ;; CY=possible increment of offset in case of revers=0
683+  054C
684+  054C E3           declzx_copy	ex	(sp),hl		;; Store address to source data and get sequence length
685+  054D F5           		push	af
686+  054E E5           		push	hl		;; Store sequence length
687+  054F              		IF revers
691+  054F              		ELSE
692+  054F 7B           		  ld	a,e		;; hl=de-bc
693+  0550 91           		  sub	c
694+  0551 6F           		  ld	l,a
695+  0552 7A           		  ld	a,d
696+  0553 98           		  sbc	a,b
697+  0554 67           		  ld	h,a
698+  0555              		ENDIF			;; and now HL points to source data of copied sequence
699+  0555 C1           		pop	bc		;; Restore BC = length of copied sequence
700+  0556              		LDXR			;; Copy sequence
700+  0556             >	IF revers
700+  0556             >	ELSE
700+  0556 7E          >.ldir	  ld	a,(hl)	;; ldir
700+  0557 12          >	  ld	(de),a
700+  0558 23          >	  inc	hl
700+  0559 13          >	  inc	de
700+  055A 0B          >	  dec	bc
700+  055B 78          >	  ld	a,b
700+  055C B1          >	  or	c
700+  055D C2 56 05    >	  jp	nz,.ldir
700+  0560             >	ENDIF
701+  0560 F1           		pop	af
702+  0561 E1           		pop	hl		;; Restore address to packed source data
703+  0562
704+  0562 C3 1A 05     		jp	declzx_main	;; Copy finished and we can continue in next block of data
705+  0565
706+  0565
707+  0565              ;; Subroutine for copying one byte
708+  0565              ;;
709+  0565              ;; Used in:
710+  0565              ;;  - direct command for copying one byte
711+  0565              ;;  - reused offset with preceded copying one byte
712+  0565
713+  0565              	    IF typcom=COMBX1 or typcom=COMBX2 or typcom=COMBX3 or typcom=COMSX1
742+  0565              	    ENDIF
743+  0565
744+  0565
745+  0565              ;; Get numeric value from bitstream
746+  0565              ;;
747+  0565              ;; Note:
748+  0565              ;; E is used as bit count instead of C and XL
749+  0565
750+  0565              	      IF typcom=COMBLX or typcom=COMBLC or typcom=COMZX9 or typpos=POSOV1 or typpos=POSOV2 or typpos=POSOV3 or typpos=POSOV4
751+  0565 1E 00        declzx_getegv0	ld	e,#00		;; Read of Elias-gamma value with no additional bits
752+  0567              	      ENDIF
753+  0567
754+  0567              declzx_getegvx	GETBIT			;; Get bit from bitstream
754+  0567             >
754+  0567             >    IF lzxspd			;; Speed optimized variant
754+  0567             >    ELSE
754+  0567 CD 82 05    >	call	declzx_getbit	;; Length optimized variant
754+  056A             >    ENDIF
754+  056A             >
755+  056A 1C           		inc	e		;; Compute zero bits before value bits
756+  056B D2 67 05     		jp	nc,declzx_getegvx
757+  056E 01 00 00     declzx_getnum	ld	bc,#00		;; Initialize destination value to zero
758+  0571
759+  0571              	    IF lzxspd			;; Speed-optimized GETBIT inlined in code
766+  0571              	    ELSE
767+  0571 D4 82 05     declzx_getloop	call	nc,declzx_getbit;; read bit (slow variant)
768+  0574              	    ENDIF
769+  0574
770+  0574 57           declzx_getnext	ld	d,a		;; Save bitstream bits into D
771+  0575 79           		ld	a,c		;; Include bit into destination value
772+  0576 17           		rla
773+  0577 4F           		ld	c,a
774+  0578 78           		ld	a,b
775+  0579 17           		rla
776+  057A 47           		ld	b,a
777+  057B 7A           		ld	a,d
778+  057C D8           		ret	c		;; If value > 65535 then return immediately with CY=1
779+  057D 1D           		dec	e		;;   (value > 65535 is usually used as end mark)
780+  057E C2 71 05     		jp	nz,declzx_getloop; Repeat for all needed bits of value
781+  0581 C9           		ret			;; Return with CY=0 (not end mark)
782+  0582
783+  0582
784+  0582              ;; Get one bit from bitstream - in case of short variant
785+  0582
786+  0582              	    IF NOT lzxspd
787+  0582 87           declzx_getbit	add	a,a		;; Reading bit from buffer (A = temporary buffer for bits)
788+  0583 C0           		ret	nz		;; If there were some bits in buffer then return
789+  0584 7E           		ld	a,(hl)		;; Buffer is empty so we must read next byte from bitstream
790+  0585 8F           		adc	a,a		;; LSB bit will be returned reading bit
791+  0586              		INCHL			;; Move to next byte in packed data
791+  0586             >	IF revers
791+  0586             >	ELSE
791+  0586 23          >	  inc	hl
791+  0587             >	ENDIF
792+  0587 C9           		ret
793+  0588              	    ENDIF
794+  0588
795+  0588              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
796+  0588
# file closed: DecLzx02-8080.asm
 24   0588
 25   0588              srcadd	INCBIN	Main.pck
 26   07FB
 27   07FB              length	=	$-start
 28   07FB
 29   07FB              	ASSERT typcom < 5 , Cannot use this compression in ROM !
 30   07FB              	ASSERT length < 1025 , Lenght of final block overflows 1kB !
 31   07FB
 32   07FB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33   07FB
# file closed: Link.a80

Value    Label
------ - -----------------------------------------------------------
0x03FB   length
0x0574 X declzx_getnext
0x0567   declzx_getegvx
0x0556   5>ldir
0x0571   declzx_getloop
0x054C   declzx_copy
0x056E   declzx_getnum
0x053B   declzx_sek
0x0565   declzx_getegv0
0x0582   declzx_getbit
0x051A   declzx_main
0x0514   declzx_ldx
0x050C X declzx_start
0x0588   srcadd
0x0009   POSOV4
0x0008   POSOV3
0x0007   POSOV2
0x0006   POSOV1
0x0004   POSOF4
0x0003   POSOF3
0x0002   POSOF2
0x0001   POSOF1
0x0009   COMSX1
0x0008   COMBX3
0x0007   COMBX2
0x0006   COMBX1
0x0005   COMBS2
0x0004   COMZX8
0x0003   COMZX9
0x0002   COMBLC
0x0001   COMBLX
0x0341   totlen
0x0273   pcklen
0x0076 X deplen
0xFFFF X maxdct
0x0004   mindst
0x0000 X ofset2
0x0005   ofset1
0x0004   bytcop
0x0007   typpos
0x0003   typcom
0x0000   revers
0x0000   lzxspd
0x050C   depack
0x0400   start
0x1CA0   dstadd
