;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Busy soft ;; DecLzx02 Universal depacker ;; 12.09.2021 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	OPT	listact	;; Exclude not compiled branches IF/ENDIF from listing

;; Setting user parameters - addresses of depacker, source and destinaton data, and optimization.
;; There are two possibilities how the setting can be provided:
;;
;;  1. Assign these labes elsewhere (i.e. in some other source code what includes this depacker)
;;     In this case, comment out these definitions, or define symbol "declzx_user_params" in your source.
;;
;;  2. Set all following values here manually

  IFNDEF declzx_user_params ;; Skip next assigns if all user data are already defined elsewhere

;; Executable address of depacker

	ORG	#8000

;; User settings of data addresses
;; (used for data overlay check too)

srcadd	=	#6000	;; Begin of source packed data
dstadd	=	#4000	;; Begin of destination area for depacked data

;; User setting optimization of depacker

lzxspd	=	0

;; Possible values of lzxspd:
;;  0 ... optimized for length - short but slow
;;  1+ .. optimized for speed  - but longer code

  ENDIF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Setting pack parameters = compression identification and data overlay check
;;
;; Next setting are generated by LzxPack and depends on used compression.
;; There are two possibilities how the setting can be provided:
;;  1. Read from *.inc file directly generated by LzxPack with option -i
;;  2. Manual setting according to compression identification and parameters

;; 1st possibility - read setting from *.inc file:
;; It is enough to uncomment following two lines
;; with include and define directives and fill
;; corresponding file name in this directive:

;	INCLUDE	filename.inc
;	DEFINE	declzx_pack_params

;; 2nd possiblity - manual setting:
;; It is needed to set proper values for following 10 labels:
;;
;;   Setting compression identification -tnXYcNoAoB (mandatory)
;;   (If some parameter is not present in identification, it does not matter)

  IFNDEF declzx_pack_params ;; If parameters are already defined (i.e. by previous include), this IF skips following definitions

revers	=	0	; n/r = Direction: 0 = normal -tn, 1 = reversed -tr
typcom	=	4	;; X = Compress type: 1=COMBLX 2=COMBLC 3=COMZX9 4=COMZX8 5=COMBS2 6=COMBX1 7=COMBX2 8=COMBX3 9=COMSX1
typpos	=	6	;; Y = Offset coding: 1=POSOF1 2=POSOF2 3=POSOF3 4=POSOF4 5=(none) 6=POSOV1 7=POSOV2 8=POSOV3 9=POSOV4
bytcop	=	0	;; N = Number of bits of copied byte - needed for BLX ZX9 BS2 BX1 BX2 BX3 SX1
ofset1	=	0	;; A = Number of bits for 1st offset - needed for OF1 OF2 OF3 OF4 OV2 OV3 OV4
ofset2	=	0	;; B = Number of bits for 1st offset - needed for OF2 OV3

;;   Setting for data overlay check (optional)

mindst	=	10	;; Minimal distance between block ends of source packed and destination unpacked data
pcklen	=	256	;; Length of source packed data
totlen	=	512	;; Length of dest unpacked data

;; LzxPack can produce two additional parameters:
;;   maxdct
;;   deplen
;; but they are not used in this depacker.

  ENDIF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Internal definitions

;; Systems for coding unpacked data and sequence lengths (values of label typcom)

COMBLX	=	1	;; Simple block compression - Elias-gamma length for both sequence and unpacked block (real sequence 1+ length supports compress simple bytes)
COMBLC	=	2	;; Simple block compression - Elias-gamma length for both sequence and unpacked block (real sequence 2+ length has width more 1 bit: EG+1)
COMZX9	=	3	;; Similar to ZX7 compression - 1 bit for each unpacked byte and 1 bit + Elias-gamma length for sequence 1+ bytes (supports packing of simple bytes)
COMZX8	=	4	;; Similar to ZX7 compression - 1 bit for each unpacked byte and 1 bit + Elias-gamma length for sequence 2+ bytes (length EG+1 bit)
COMBS2	=	5	;; Bitstream 1:unpack byte, 01:seq 2 bytes, 001:seq 3 bytes, 0001:seq 4+ bytes, 00000:1 unpack + rep offset, 00000:unpacked block 10+ bytes
COMBX1	=	6	;; Bitstream 1:unpack, 01:seq2, 001:seq3, 0001:copied, 00001:seq4+, 000001:unpack + rep.offset, 0000001:copied + rep.offs, 0000000:block 12+
COMBX2	=	7	;; Bitstream 1:unpack, 01:seq2, 001:copied, 0001:seq3, 00001:seq4+, 000001:unpack + rep.offset, 0000001:copied + rep.offs, 0000000:block 12+
COMBX3	=	8	;; Bitstream 1:unpack, 01:copied, 001:seq2, 0001:seq3, 00001:seq4+, 000001:unpack + rep.offset, 0000001:copied + rep.offs, 0000000:block 12+
COMSX1	=	9	;; Bitstream 1:seq 2+, 01:unpack, 001:copied, 0001:unpack + rep offset, 00001:copied + rep offset, 00000:unpack block 5+ bytes

;; Systems for coding offsets in sequences (values of label typpos)

POSOF1	=	1	;; One fixed offset used for all sequences
POSOF2	=	2	;; Two fixed offsets (similar to ZX7)
POSOF3	=	3	;; Three fixed step offsets (1,2,3 or 2,4,6 or 3,6,9 or 4,8,12 or 5,10,15)
POSOF4	=	4	;; Four fixed step offsets (1,2,3,4 or 2,4,6,8 or 3,6,9,12 or 4,8,12,16 bits)
;;;;;;	=	5	;; (not used)
POSOV1	=	6	;; Simple variable Elias-gamma coding offset
POSOV2	=	7	;; One fixed offset and one variable offset
POSOV3	=	8	;; Two fixed offsets A,B and one variable Elias-gamma offset EG+B bits and +A addition
POSOV4	=	9	;; Three fixed step offsets (1,2,3 or 2,4,6 or 3,6,9 or 4,8,12) and one variable offset

;; You can use these constants to define labels "typcom" and "typpos" in definition of compress type -tnXYcNoAoB

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Macro definitions

LDX	MACRO
	IF revers
	  ldd
	ELSE
	  ldi
	ENDIF
	ENDM

LDXR	MACRO
	IF revers
	  lddr
	ELSE
	  ldir
	ENDIF
	ENDM

INCHL	MACRO
	IF revers
	  dec	hl
	ELSE
	  inc	hl
	ENDIF
	ENDM

INCOFS	MACRO
	IF revers
	  inc	bc
	ELSE
	  scf
	ENDIF
	ENDM

GETBIT	MACRO			;; Get one bit from bitstream

    IF lzxspd			;; Speed optimized variant
	add	a,a		;; Reading bit from buffer (A = temporary buffer for bits)
	jp	nz,.end		;; If there were some bits in buffer then return
	ld	a,(hl)		;; Buffer is empty so we must read next byte from bitstream
	adc	a,a		;; MSB bit will be returned reading bit
	INCHL			;; Move to next byte in packed data
.end
    ELSE
	call	declzx_getbit	;; Length optimized variant
    ENDIF

	ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Validation of parameters 'typcom' and 'typpos'
;; to make sure they contain only supported values

	ASSERT	typcom=COMBLX or typcom=COMBLC or typcom=COMZX9 or typcom=COMZX8 or typcom=COMBS2 or typcom=COMBX1 or typcom=COMBX2 or typcom=COMBX3 or typcom=COMSX1
	ASSERT	typpos=POSOF1 or typpos=POSOF2 or typpos=POSOF3 or typpos=POSOF4 or                  typpos=POSOV1 or typpos=POSOV2 or typpos=POSOV3 or typpos=POSOV4

;; Data overlay check
;; to make sure destination depacked data does not overwrite source packed data not used yet

	IF revers
	  ASSERT  srcadd + mindst <= dstadd  OR  dstadd + totlen <= srcadd
	ELSE
	  ASSERT  dstadd + totlen + mindst <= srcadd + pcklen  OR  srcadd + pcklen <= dstadd
	ENDIF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Start of depacker

;; Set input and output addresses.
;; It can be commented out and done in calling program.

declzx_start	IFNDEF declzx_init_addres	;; Skip next setting HL,DE if they are set from calling program.

		  IF revers
		    ld	hl,srcadd+pcklen-1	;; In case of reversed unpacking,
		    ld	de,dstadd+totlen-1	;; it is need to set address of last byte
		  ELSE
		    ld	hl,srcadd
		    ld	de,dstadd
		  ENDIF

		ENDIF

;; Input:
;;  HL = address of source packed data
;;  DE = address of destination to depack data
;; When reversed direction (revers=1) is used, HL and DE must point to last byte of data.

		ld	a,#80		;; Initial value what means there are no bits from bitstream in A

;; Processing compression types and lengths

	    IF typcom=COMBLX

		db	#01		;; ld bc,... => skip following LDIR / LDDR
declzx_ldx	LDXR
declzx_main	call	declzx_getegv0	;; Get length of next block             *** BLX compression ***
		ret	c		;; Return if end mark occured
		GETBIT
		jr	c,declzx_ldx	;; 1 ... unpacked block
		push	bc		;; 0 ... sequence
		dec	c
		jr	nz,declzx_sek	;; Jump if length > 1
		inc	b
		djnz	declzx_sek
		ld	c,bytcop	;; Sequence length = 1 means copying one standalone byte
		call	declzx_getnum	;; Read offset for copying byte from bitstream
		inc	c		;; Increment offset
		jr	declzx_copy	;; Jump copying sequence (in this case only one byte)

declzx_sek				;; Continue to read sequence offset

	    ENDIF


	    IF typcom=COMBLC

declzx_main	GETBIT			;; Get ID of next block                *** BLC compression ***
		jr	nc,declzx_blc	;; 1 = unpacked block, 0 = sequence
		call	declzx_getegv0	;; Get length of unpacked block
		LDXR			;; Copy unpacked block
		jr	declzx_main

declzx_blc	ld	c,#01		;; Get Elias-Gamma with one addtional bit
		call	declzx_getegvx	;; Read length of sequence from bitstream
		ret	c		;; Return if end mark occured
		push	bc		;; Continue to read sequence offset
	    ENDIF


	    IF typcom=COMZX9

declzx_ldx	LDX			;; Copy one unpacked byte                 *** ZX9 compression ***
declzx_main	GETBIT
		jr	c,declzx_ldx	;; 1 ... one unpacked byte, 0 ... sequence
		call	declzx_getegv0	;; Get length of sequence
		ret	c		;; Return if end mark occured
		push	bc
		dec	c
		jr	nz,declzx_sek	;; Jump if length > 1
		inc	b
		djnz	declzx_sek
		ld	c,bytcop	;; Sequence length = 1 means copying one standalone byte
		call	declzx_getnum	;; Read offset for copying byte from bitstream
		inc	c		;; Increment offset
		jr	declzx_copy	;; Jump copying sequence (in this case only one byte)

declzx_sek				;; Continue to read sequence offset

	    ENDIF


	    IF typcom=COMZX8

declzx_ldx	LDX			;; Copy one unpacked byte                 *** ZX8 compression ***
declzx_main	GETBIT
		jr	c,declzx_ldx	;; 1 ... one unpacked byte
		ld	c,#01		;; 0 ... sequence 2+ bytes
		call	declzx_getegvx	;; Read sequence length from bitstream
		ret	c		;; If length > 65535 then end of data (end mark)
		push	bc		;; Continue to read sequence offset

	    ENDIF


	    IF typcom=COMBS2

declzx_ldx	LDX			;; Copy one unpacked byte                 *** BS2 compression ***
declzx_main	GETBIT
		jr	c,declzx_ldx	;; 1 ... next unpacked byte follows
		ld	bc,#02		;; Set length to 2
		GETBIT
		jr	c,declzx_push	;; 01 ... sequence (length=2) follows
		inc	c		;; Set length to 3
		GETBIT
		jr	c,declzx_push	;; 001 ... sequence (length=3) follows
		GETBIT
		jr	c,declzx_sek	;; 0001 ... sequence (length=4+) follows
		GETBIT
		jr	c,declzx_reuse	;; 00001 ... one unpack byte + reused offset
		call	declzx_getegvx	;; 00000 ... get length of unpacked block (length = EG+3)
		ret	c		;; If length > 65535 then end of data (end mark)
		inc	bc		;; Length >= 9
		LDXR			;; Copy unpacked data
		jr	declzx_ldx	;; Copy one additional unpacked byte for length >= 10

declzx_reuse	LDX			;; Copy one byte
		ld	c,#01
		call	declzx_getegvx	;; Sequence length EG+1
		push	bc
declzx_last	ld	bc,#5555	;; Previous used offset
		IF NOT revers AND (typpos=POSOF1 or typpos=POSOF2 or typpos=POSOV2 or typpos=POSOV3)
		  scf
		ENDIF
		jr	declzx_copy

declzx_sek	dec	c		;; C=2
		call	declzx_getegvx	;; Get length of packed sequence EG+2 (length >= 4)
declzx_push	push	bc		;; Continue to read sequence offset

	    ENDIF


	    IF typcom=COMBX1

declzx_ldx	LDX			;; Copy one unpacked byte                 *** BX1 compression ***
declzx_main	GETBIT
		jr	c,declzx_ldx	;; 1 ... one unpacked byte
		ld	bc,#02
		GETBIT
		jr	c,declzx_push	;; 01 ... sequence 2 bytes
		inc	c
		GETBIT
		jr	c,declzx_push	;; 001 ... sequence 3 bytes
		dec	c		;; C = 2
		GETBIT
		jr	c,declzx_onemain;; 0001 ... one copied byte
		GETBIT
		jr	c,declzx_sek	;; 00001 ... sequence 4+ bytes
		GETBIT
		jr	c,declzx_repunp	;; 000001 ... one unpack byte + reused offset
		GETBIT
		jr	c,declzx_repcpy	;; 0000001 ... one unpack byte + reused offset
		inc	c		;; C = 3
		call	declzx_getegvx	;; 0000000 ... unpacked block (length = EG+3)
		inc	bc
		inc	bc
		inc	bc		;; Length += 3
		LDXR			;; Copy unpacked data
		jr	declzx_ldx	;; Copy one additional unpacked byte for length >= 12

	    ENDIF


	    IF typcom=COMBX2

declzx_ldx	LDX			;; Copy one unpacked byte                 *** BX2 compression ***
declzx_main	GETBIT
		jr	c,declzx_ldx	;; 1 ... one unpacked byte
		ld	bc,#02
		GETBIT
		jr	c,declzx_push	;; 01 ... sequence 2 bytes
		GETBIT
		jr	c,declzx_onemain;; 001 ... one copied byte
		inc	c
		GETBIT
		jr	c,declzx_push	;; 0001 ... sequence 3 bytes
		dec	c		;; C = 2
		GETBIT
		jr	c,declzx_sek	;; 00001 ... sequence 4+ bytes
		GETBIT
		jr	c,declzx_repunp	;; 000001 ... one unpack byte + reused offset
		GETBIT
		jr	c,declzx_repcpy	;; 0000001 ... one unpack byte + reused offset
		inc	c		;; C = 3
		call	declzx_getegvx	;; 0000000 ... unpacked block (length = EG+3)
		inc	bc
		inc	bc
		inc	bc		;; Length += 3
		LDXR			;; Copy unpacked data
		jr	declzx_ldx	;; Copy one additional unpacked byte for length >= 12

	    ENDIF


	    IF typcom=COMBX3

declzx_ldx	LDX			;; Copy one unpacked byte                 *** BX3 compression ***
declzx_main	GETBIT
		jr	c,declzx_ldx	;; 1 ... one unpacked byte
		GETBIT

		IF lzxspd		;; 01 ... one copied byte
		  jp	c,declzx_onemain
		ELSE
		  jr	c,declzx_onemain
		ENDIF

		ld	bc,#02
		GETBIT
		jr	c,declzx_push	;; 001 ... sequence 2 bytes
		inc	c
		GETBIT
		jr	c,declzx_push	;; 0001 ... sequence 3 bytes
		dec	c		;; C = 2
		GETBIT
		jr	c,declzx_sek	;; 00001 ... sequence 4+ bytes
		GETBIT
		jr	c,declzx_repunp	;; 000001 ... one unpack byte + reused offset
		GETBIT
		jr	c,declzx_repcpy	;; 0000001 ... one unpack byte + reused offset
		inc	c		;; C = 3
		call	declzx_getegvx	;; 0000000 ... unpacked block (length = EG+3)
		inc	bc
		inc	bc
		inc	bc		;; Length += 3
		LDXR			;; Copy unpacked data
		jr	declzx_ldx	;; Copy one additional unpacked byte for length >= 12

	    ENDIF


	    IF typcom=COMSX1

declzx_ldx	LDX			;; Copy one unpacked byte                 *** SX1 compression ***
declzx_main	ld	bc,#01		;; Set length to 1
		GETBIT
		jr	c,declzx_sek	;; 1 ... regular 2+ sequence
		GETBIT
		jr	c,declzx_ldx	;; 01 ... one unpacked byte
		GETBIT
		jr	c,declzx_onemain;; 001 ... one copied byte
		GETBIT
		jr	c,declzx_repunp	;; 0001 ... one unpack byte + reused offset
		GETBIT
		jr	c,declzx_repcpy	;; 00001 ... one copied byte + reused offset
		inc	c		;; C = 2
		call	declzx_getegvx	;; 00000 ... unpacked block (length = EG+2)
		LDXR			;; Copy unpacked data
		jr	declzx_ldx	;; Copy one additional unpacked byte for length >= 5

	    ENDIF


	    IF typcom=COMBX1 or typcom=COMBX2 or typcom=COMBX3 or typcom=COMSX1

declzx_repcpy	call	declzx_onebyte
		db	#01		;; Jump to declzx_reuse
declzx_repunp	LDX			;; Copy one byte
declzx_reuse	ld	c,#01
		call	declzx_getegvx	;; sequence length EG+1
		push	bc
declzx_last	ld	bc,#5555	;; Previous used offset
		IF NOT revers AND (typpos=POSOF1 or typpos=POSOF2 or typpos=POSOV2 or typpos=POSOV3)
		  scf
		ENDIF
		jr	declzx_copy

declzx_sek	call	declzx_getegvx	;; Get length of packed sequence (length >= 4)
		ret	c		;; If length > 65535 then end of data (end mark)
declzx_push	push	bc		;; Continue to read sequence offset

	    ENDIF


;; Clear carry if needed (some offset readings need CY=0 at begin)

	    IF (typcom >= COMBS2) and (typpos=POSOF1 or typpos=POSOF4 or typpos=POSOV4)
		and	a
	    ENDIF


;; Processing offsets

	    IF typpos=POSOF1
		ld	c,ofset1	;; Number of bits of one fixed offset		*** OF1 offset ***
		call	declzx_getnum	;; Read value (C=number of value bits)
		INCOFS			;; Increment offset value (for later sbc hl,bc)

		ASSERT	ofset1 >= 1 and ofset1 <= 16
	    ENDIF


	    IF typpos=POSOF2
		ld	bc,#FFFF	;; Set offset to -1				*** OF2 offset ***
		ld	xl,ofset2-ofset1;; We will read N bits, N = difference between bitwidth of offsets
		GETBIT
		call	nc,declzx_getnumx; If longer offset then reading N bits - it is first part of offset
		and	a		;; Clearing carry only (later 'call declzx_getloop' needs it)
		inc	bc		;; Increment offset (-1 => 0, or part of longer offset + 1)
		ld	xl,ofset1	;; Number of bits of shorter offset
		call	declzx_getloop	;; Reading bits of offset (next part of longer or entire shorter offset)
		INCOFS			;; Next increment offset value (for later sbc hl,bc)

		ASSERT	ofset1 >= 1 and ofset1 < ofset2 and ofset2 <=16
	    ENDIF


	    IF typpos=POSOF3
		ld	bc,#01		;; Init counter to 1				*** OF3 offset ***
		GETBIT
		jr	nc,declzx_of3set;; Bit 0 => counter 1
		GETBIT
		rl	c		;; Bit 1x => counter 2+x
declzx_of3set	ld	xh,c		;; XH will be reading offset counter
		ld	c,b		;; Clearing BC for next reading offset value
declzx_of3lop	ld	xl,ofset1	;; Number of bits of one part of offset
		call	declzx_getloop	;; Reading part of offset
		inc	bc		;; Increment temporary offset value
		dec	xh		;; (it is needed for covering of bigger interval)
		jr	nz,declzx_of3lop;; Repeat for given with of offset

		ASSERT	ofset1 >= 1 and ofset1 <= 5
	    ENDIF


	    IF typpos=POSOF4
		ld	c,#02		;; Next two bits means offset width		*** OF4 offset ***
		call	declzx_getnum	;; Reading these two bits from bitstream
		inc	c		;; Adjust two bits to value in range 1..4
		ld	xh,c		;; XH will be reading offset counter
		ld	c,b		;; Clearing BC for next reading offset value
declzx_of4lop	ld	xl,ofset1	;; Number of bits of one part of offset
		call	declzx_getloop	;; Reading part of offset
		inc	bc		;; Increment temporary offset value
		dec	xh		;; (it is needed for covering of bigger interval)
		jr	nz,declzx_of4lop;; Repeat for given with of offset

		ASSERT	ofset1 >= 1 and ofset1 <= 4
	    ENDIF


	    IF typpos=POSOV1
		call	declzx_getegv0		;; Read Elias-Gamma value (it is enough)	*** OV1 offset ***
	    ENDIF


	    IF typpos=POSOV2
		ld	bc,#0000	;; Init offset to 0				*** OV2 offset ***
		GETBIT
		call	c,declzx_getegvx;; Case 1 ... Read Elias-Gamma - only additional variable part
		ld	xl,ofset1	;; Number of bits of shorter offset
		call	declzx_getloop	;; Read shorter offset or fixed part of variable offset
		INCOFS			;; Increment offset value for range 1..X

		ASSERT	ofset1 >= 1 and ofset1 <= 14
	    ENDIF


	    IF typpos=POSOV3
		ld	bc,#0000	;; Set offset to 0				*** OV3 offset ***
		GETBIT
		jr	nc,declzx_ov3set;; Case 0 ... Jump for 0 to direct read shorter offset
		GETBIT
		call	c,declzx_getegvx;; Case 11 ... Read Elias-Gamma - only additional variable part
		ld	xl,ofset2-ofset1;; We will read N bits, N = difference between bitwidth of offsets
		call	declzx_getloop	;; If longer offset then reading N bits - it is first part of offset
		inc	bc		;; Increment offset here means add value 1 << ofset1 in result
declzx_ov3set	ld	xl,ofset1	;; Number of bits of shorter offset
		call	declzx_getloop	;; Reading bits of offset (next part of longer or entire shorter offset)
		INCOFS			;; Final increment offset value for range 1..X

		ASSERT	ofset1 >= 1 and ofset2 <=14 and ofset1 < ofset2
	    ENDIF


	    IF typpos=POSOV4
		ld	c,#02		;; Next two bits means offset width		*** OV4 offset ***
		call	declzx_getnum	;; Reading these two bits from bitstream
		inc	c		;; Adjust two bits to value in range 1..4
		ld	xh,c		;; XH will be reading offset counter
		bit	2,c		;; Test for case 11 = variable offset
		ld	c,b		;; Clearing BC for next reading offset value
		jr	z,declzx_ov4lop
		call	declzx_getegvx
		dec	xh
declzx_ov4lop	ld	xl,ofset1	;; Number of bits of one part of offset
		call	declzx_getloop	;; Reading part of offset
		inc	bc		;; Increment temporary offset value
declzx_ov4nxt	dec	xh		;; (it is needed for covering of bigger interval)
		jr	nz,declzx_ov4lop;; Repeat for given with of offset

		ASSERT	ofset1 >= 1 and ofset1 <= 5
	    ENDIF


    IF typcom=COMBS2 or typcom=COMBX1 or typcom=COMBX2 or typcom=COMBX3 or typcom=COMSX1
		ld	(declzx_last+1),bc ;; Store actual offset for future "reused offset"
	    ENDIF


;; Copy sequence
;;
;; BC=offset, (SP)=length, DE=destination
;; CY=possible increment of offset in case of revers=0

declzx_copy	ex	(sp),hl		;; Store address to source data and get sequence length
		push	hl		;; Store sequence length
		ld	h,d		;; DE keeps destination address whole time
		ld	l,e		;; Subtract offset from destination address

		IF revers
		  add	hl,bc		;; and now HL points to source data of copied sequence
		ELSE
		  sbc	hl,bc		;; and now HL points to source data of copied sequence
		ENDIF

		pop	bc		;; Restore BC = length of copied sequence
		LDXR			;; Copy sequence
		pop	hl		;; Restore address to packed source data

		IF lzxspd		;; Copy finished and we can continue in next block of data
		  jp	declzx_main
		ELSE
		  jr	declzx_main
		ENDIF


;; Subroutine for copying one byte
;;
;; Used in:
;;  - direct command for copying one byte
;;  - reused offset with preceded copying one byte

	    IF typcom=COMBX1 or typcom=COMBX2 or typcom=COMBX3 or typcom=COMSX1

declzx_onemain	ld	bc,declzx_main	;; After process, jump to declzx_main
		push	bc
declzx_onebyte	or	a
		ld	c,bytcop	;; Bit width of offset for copying standalone bytes
		call	declzx_getnum	;; Read offset from bitstream
		IF revers		;; Revers-dependend increment of offset
		  inc	bc
		ELSE
		  scf
		ENDIF
		push	hl		;; Store source address
		ld	h,d		;; DE keeps destination address whole time
		ld	l,e		;; Subtract offset from destination address
		IF revers
		  add	hl,bc
		ELSE
		  sbc	hl,bc
		ENDIF			;; and now HL points to copied byte in data
		LDX			;; Copying one byte from (HL) do (DE)
		pop	hl		;; Restore source address to packed data
		ret

	    ENDIF


;; Get numeric value from bitstream

	      IF typcom=COMBLX or typcom=COMBLC or typcom=COMZX9 or typpos=POSOV1
declzx_getegv0	ld	c,#00		;; Read of Elias-gamma value with no additional bits
	      ENDIF

declzx_getegvx	GETBIT			;; Get bit from bitstream
		inc	c		;; Compute zero bits before value bits
		jr	nc,declzx_getegvx
declzx_getnum	ld	xl,c		;; XL = bit width of next reading value
declzx_getnumx	ld	bc,#00		;; Initialize destination value to zero

	    IF lzxspd			;; Speed-optimized GETBIT inlined in code
		jr	c,declzx_getnext;; First CY=1 is needed to rotate into BC always
declzx_getloop	add	a,a		;; Read bit from buffer (A = temporary buffer for bits)
		jr	nz,declzx_getnext; If there were some bits in buffer then return
		ld	a,(hl)		;; Buffer is empty so we must read next byte from bitstream
		adc	a,a		;; MSB bit will be returned reading bit
		INCHL			;; Move to next byte in packed data
	    ELSE
declzx_getloop	call	nc,declzx_getbit;; read bit (slow variant)
	    ENDIF

declzx_getnext	rl	c		;; Include bit into destination value
		rl	b		;;
		ret	c		;; If value > 65535 then return immediately with CY=1
		dec	xl		;;   (value > 65535 is usually used as end mark)
		jr	nz,declzx_getloop; Repeat for all needed bits of value
		ret			;; Return with CY=0 (not end mark)


;; Get one bit from bitstream - in case of short variant

	    IF NOT lzxspd
declzx_getbit	add	a,a		;; Reading bit from buffer (A = temporary buffer for bits)
		ret	nz		;; If there were some bits in buffer then return
		ld	a,(hl)		;; Buffer is empty so we must read next byte from bitstream
		adc	a,a		;; LSB bit will be returned reading bit
		INCHL			;; Move to next byte in packed data
		ret
	    ENDIF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
